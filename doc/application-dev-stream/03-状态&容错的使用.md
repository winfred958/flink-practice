# 状态与容错

- 使用State
    - [使用Keyed State]()
    - [使用Operator State]()
    - [使用Broadcast State]()
    

## 使用 State

### 使用 Keyed State [官网](https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/stream/state/state.html#using-keyed-state)

```text
You can specify a key using keyBy(KeySelector) on a DataStream
DataStream ===keyBy(KeySelector)==> KeyedStream
KeyedStream 可以被 keyed state 作用
```

- 实现方式
    - **重写 RichXxxFunction, 通过 RuntimeContext getState 访问**
    - ```text
      RichXxxFunction 提供了 open, close, setRuntimeContext, setRuntimeContext 方法,
           可以用于参数化function, 创建和最终确定本地状态, 访问广播变量, Runtime 信息
           例如累加和计数器, 迭代器相关信息
      ```
    - 常规操作
        - open 方法中 getState
        - 重写的算子逻辑中 update state & clean state
- 所有支持的State
    - ValueState<T>
    - ListState<T>
    - ReducingState<T>
    - AggregationState<IN, OUT>
    - MapState<UK, UV>

### 使用 Operator State [官网](https://ci.apache.org/projects/flink/flink-docs-release-1.12/dev/stream/state/state.html#using-operator-state)

- 用户通过 implement CheckpointedFunction 接口使用 operator state
    - 实现如下两个方法
        - ```java
          void snapshotState(FunctionSnapshotContext context) throws Exception;
          void initializeState(FunctionInitializationContext context) throws Exception;
          ```
    - 用户自定义函数初始化时调用initializeState(), 进行 checkpoint 时会调用 snapshotState(), init 包括第一次自定义函数初始化和从之前的checkpoint恢复, 因此,
      initializeState()不仅仅是定义不同状态类型初始化的地方, 也需要包括状态恢复的逻辑.

### 使用 Broadcast State
- Broadcast State 是一种特殊的 Operator State
- 使用 Broadcast 是为了支持上游的个DataStream的状态需要被广播到下游task的目的, 下游的task可以方位这个State.
- 考虑到上述用例, broadcast state 和 operator state 区别
    - broadcast state 是个map
    - broadcast state 只能被特殊的 operator 使用
    - an operator 可以有 多个不同名称的 broadcast state

